コンポーネントが何かを覚えるためには、stateというものを使う

Reactコンポーネントはコンストラクタでthis.stateを設定することで、状態を保てる
this.stateはそれが定義されているコンポーネント内でプライベートと見なすべき

stateのリフトアップ
ゲームの状態を各Squareの代わりに親のBoardコンポーネントで保持することでコードを綺麗に保てる
BoardコンポーネントはそれぞれのSquareにpropsを渡すことで、何を表示するべきかを伝えられる
→ 複数の子要素からデータを集めたい、または2つの子コンポーネントに互いにやりとりさせたいと思った場合、
  代わりに親コンポーネント内で共有のstateを宣言する必要がある
  親コンポーネントはpropsを使うことで子に情報を返すことができる

  子コンポーネントが兄弟同士、あるいは親との間で常に同期されるようになる

  → stateを親コンポーネントにリフトアップすることはReactコンポーネントのリファクタリングでよくあること


イミュータビリティはなぜ重要か
データの扱いは直接書き換えるか、新しいデータのコピーで古いデータを置き換えるか
→ 直接データのミューテート(内部データの書き換え)をしないことで利点がある
1. 複雑な機能が簡単に実装できる
   → 履歴を振り返って、巻き戻しができる
2. 変更の検出
   → 参照しているイミュータブルなオブジェクトが前と別のものであれば、変更があったと判断
3. Reactの再レンダータイミングの決定
   イミュータビリティの主な利点は、Reactでpure componentを構築しやすくなる


関数コンポーネントに書き換える
Reactにおける関数コンポーネントとは、renderメソッドだけを有して自分のstateを持たないコンポーネントを、よりシンプルに書くための方法
React.Componentを継承するクラスを定義する代わりに、propsを入力として受け取り表示すべき内容を返す関数を定義する
関数コンポーネントはクラスを書くよりも楽である


タイムトラベル機能
keyを選ぶ
リストをレンダーする際、リストの項目それぞれについて、Reactはとある情報を保持する
リストが変更になった場合、Reactはどのアイテムが変更になったのかを知る必要がある

リストの項目それぞれに対してkeyプロパティを与えることで、兄弟要素の中でそのアイテムが区別できるようにする

<li>Alexa: 7 tasks left</li>
<li>Ben: 5 tasks left</li>

↓

<li>Ben: 9 tasks left</li>
<li>Claudia: 8 tasks left</li>
<li>Alexa: 5 tasks left</li>

#####
<li key={user.id}>{user.name}: {user.taskCount} tasks left</li>
#####


リストが再レンダーされる際、Reactはそれぞれのリスト項目のkeyについて、前回のリスト項目内に同じkeyを持つものがないか探す
もし以前になかったkeyがリストに含まれていれば、Reactはコンポーネントを作成する
もし以前のリストにあったkeyが新しいリストに含まれていなければ、Reactは以前のコンポーネントを削除する
もし2つのkeyがマッチした場合、対応するコンポーネントは移動される
keyはそれぞれのコンポーネントの同一性に関する情報をReactに与え、それによりReactは再レンダー間でstateを保持できるようになる
もしコンポーネントのkeyが変化していれば、コンポーネントは破棄されて新しいstateで再作成される

keyは特殊なプロパティであり、Reactによって予約されている（より汎用的な昨日のrefも同様）
keyはpropsの一部のように感じるが、this.props.keyで参照できない
Reactはどの子要素を更新するべきかを決定する際に、keyを自動的に使用する
コンポーネントが自身のkeyについて確認する方法はない

→ 動的なリストを構築する場合は正しいkeyを割り当てることが強く推奨される
keyが指定されなかった場合、Reactは警告を表示し、デフォルトでkeyとして配列のインデックスを使用する
配列のインデックスをkeyをして使うことは、項目を並び替えたり挿入/削除する際に問題になる
keyはグローバルに一意である必要はなく、コンポーネントとその兄弟の間で一意であれば良い

